## 资源加载和网络栈
### WebKit 资源加载机制
#### 资源

下面是主要的资源类型：

- HTML：HTML 页面。
- JavaScript：JavaScript 代码，这里指的应该都是外联的。（虽然书上不这么说）
- Css 样式表：Css 样式资源，这里指的应该都是外联的。（虽然书上不这么说）
- 图片：各种编码格式的图片资源。
- SVG：用户绘制 SVG 的 2D 矢量图。
- Css Shader：为 Css 技术带来3D图形特性。
- 视频、音频、字幕。
- 字体文件：Css 支持自定义字体，Css3 引入自定义字体文件。
- XSL 样式表：用 XSLT 语言编写的 XSLT 代码文件。

它们在 WebKit 内部对应了不同的资源类，这些资源类都是 `CachedResource` 类的子类。继承 `CachedResource` 类目的是为了引入缓存机制。另外特殊的一个是 HTML 资源，它在 WebKit 中对应的类型是 `MainResource`，与其对应的资源类是 `CachedRawResource`，同样是 `CachedResource` 类的子类

#### 资源缓存

缓存资源是提高资源利用率的十分有效的做法。其最基本的思想就是建立一个资源缓存池，每次请求资源前都先去资源缓存池中查找，只有不存在时 WebKit 才会创建新的资源类用网络模块去请求资源，请求后将其设置到该资源类，缓存起来。而查找资源的关键字就是资源的 URL。

![](../img/资源缓存机制.jpg)

> 注意：的是这里的缓存中的是内存缓存，和后文网络栈部分的磁盘缓存不同。并且真实的过程要比上图描述得要复杂很多。

#### 资源加载器

WebKit 三类加载器：

1. 针对每种资源类型特定的加载器：如 `FontLoader`、`ImageLoader`，它们没用公共基类。
2. 资源缓存机制的资源加载器：所有特定加载器都共享它来查找和插入缓存资源。
3. 通用的资源加载器：只负责获得资源数据。

先了解，具体会在加载过程一节详细介绍。

#### 过程

以一张图片的加载过程为例：

![](../img/资源加载过程.jpg)

1. `FrameLoader` 页面框架的加载器。
2. 加载完页面，在解析 HTML 到 img 元素时会创建一个 `ImageLoader` 资源类。
3. `ImageLoader` 资源类发起一个缓存资源加载的请求。
4. 此时会调用 `CachedResourceLoader` 来从缓存中获取。
5. 如果没有缓存，则会发起一个资源请求，此时调用的是 `ResourceLoader` 只负责获得资源数据。
6. 最后就会交由各个移植的网络模块相关的实现来加载资源。

> 为了不阻塞页面的渲染，大多数的加载都是异步的，目前我所知的只有 JavaScript 的加载是同步并且立即执行，阻塞页面的渲染的。所以一般将其放在页面底部。当然也有异步的做法，具体可以看我的一篇[博客](https://m2mbob.cn/2016/10/06/js-tong-bu-yi-bu-jia-zai-xiao-jie/)。

#### 资源的生命周期

1. 缓存池有限？
2. 什么时候需要更新资源？

解决第一个问题用的是 [LRU 算法](http://flychao88.iteye.com/blog/1977653)，这是操作系统中页面置换的一种算法，也通常被用作缓存淘汰算法。但是个人认为真正使用的应该是基于 LRU 的算法，例如 LRU-2、MQ(2)。

第二问题涉及 HTTP 的缓存机制，也就是如何知道一个资源在服务器上更新了，这种情况下即使有缓存也需要重新加载资源。两种情况，当设置了过期时间，那么这个资源在未过期的情况下就会按上面的过程加载资源，此时会从缓存中获取，不会发出 HTTP 请求，对应的状态码是 200（from cache）。如果资源过期，那么发起请求，这时服务器来进行判断，如果资源没有变，则会返回 304 状态码，还是从缓存中获取；资源改变，则返回新的资源。另外不同的用户行为也会影响资源的加载，例如 Ctrl+F5刷新，就会使 `Expires/Cache-Control` 和 `Last-Modified/Etag` 都无效，进行资源加载。具体可以看我的另一篇[博客](https://m2mbob.cn/2016/08/14/http-huan-cun/)。

### Chromium 多进程资源加载

#### 多进程

#### 工作方式和资源共享

### 网络栈